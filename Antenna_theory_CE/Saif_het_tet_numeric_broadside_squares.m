
%% clear workspace

clear all;

close force all;

clc;

%% connect needed folders

addpath(genpath('C:\Users\Pavel\Documents\MATLAB'));

%% Control flags

compute_array = 0; % add numerical computation of an array as single entity, taking elements coupling into account

plot_FF = 1; % plot normalized radiation curve

plot_current = 1; % plot surface currents on the dipole

%% Define physical constants

c = 3e8;

mu = 4*pi*1e-7;

epsilon = 8.854e-12;

%% Define frequency - related constants

Lambda = 1;

f = c / Lambda;

w = 2*pi*f;

%% Define scattering body (z-axed cylinder in this case)

half_l = 0.7311/2*Lambda; % half_l is half of the length of the dipole

% half_l = 1.1/2*Lambda; % half_l is half of the length of the dipole

% half_l = 1*Lambda; % half_l is half of the length of the dipole

R = 0.0025*Lambda; % R is radius of the dipole wire

D = 2*Lambda; % D is distance between array elements

%% Define excitation

% Excitation here is desired current on surface of the dipole

Delta_z_size = 0.01*Lambda;

Einc = Vector_field(Function3(@(c1,c2,c3)0),...
                    Function3(@(c1,c2,c3)0),...
                    Function3(@(c1,c2,c3)(abs(c3) <= Delta_z_size/2)),...
                    'cart');
                
if compute_array

    Einc_array = Vector_field(Function3(@(c1,c2,c3)0),...
                        Function3(@(c1,c2,c3)0),...
                        Function3(@(c1,c2,c3)(abs(c3 + D/2) <= Delta_z_size/2) + (abs(c3 - D/2) <= Delta_z_size/2)),...
                        'cart');
                
end



%% Define current elements number

N_currents = 21;

currents_limits = linspace(-half_l, half_l, N_currents+1);

N_currents_array = 2*N_currents; %% Don't change this, will affect for loops further!

currents_limits_array = [linspace(-half_l - D/2, half_l - D/2, N_currents_array/2+1) linspace(-half_l + D/2, half_l + D/2, N_currents_array/2+1)];

%% Define weighting functions number

N_weights = 21;

weights_limits = linspace(-half_l, half_l, N_weights+1);

if compute_array

    N_weights_array = N_currents_array;

    weights_limits_array = [linspace(-half_l - D/2, half_l - D/2, N_weights_array/2+1) linspace(-half_l + D/2, half_l + D/2, N_weights_array/2+1)];

end

%% Define integration grid

N_height = 2*floor(2*half_l/R) + 1; % amount of points in z direction

N_phi = 1;

%% Define Green function

Green = G(w/c); % calls constructor of Green functions class

%% Define numeric differentiation constants

d_x = min([0.0005*Lambda, 2*half_l/N_height/5]);

d_y = min([0.0005*Lambda, 2*half_l/N_height/5]);

d_z = min([0.0005*Lambda, 2*half_l/N_height/5]);


%% Define base currents and their derivatives - Vector potentials and electric fields

Currents = cell(N_currents,1);

Es = cell(N_currents,1);

parfor n = 1:N_currents % create array of E-field functions generated by base currents located on the side of the dipole
    
    aux1 = currents_limits(n);

    aux2 = currents_limits(n+1);
        
    f_string = sprintf('@(c1,c2,c3)(c3 >= %.15f)*(c3 < %.15f)', aux1, aux2);
    
    current_J = Vector_field(Function3(@(c1,c2,c3)0),...
                             Function3(@(c1,c2,c3)0),...
                             Function3(eval(f_string)),...
                             'cart'); % Define current in z direction
                            
    Currents{n} = current_J;
    
    N_height_in_support = ceil((aux2-aux1) / (2*half_l/N_height));
       
    Current_A = Green_integral(Green, current_J, 'no', 0, 0, aux1, 0, 0, aux2, 1, 1, N_height_in_support, 'cart'); % Compute vector potential produced by z current
      
    Es{n} = Current_A*(-1i*w) + Grad(Div(Current_A, d_x, d_y, d_z),d_x, d_y, d_z)*(1/(1i*w*epsilon*mu)); % Compute E-field produced by z current
       
    fprintf('Current number = %d\n', n);
       
end

% Here computation of array currents is not optional, it's used later even
% if entire array is not computed

Currents_array = cell(N_currents_array,1); % define cell array of currents at each of the points, two per point

Es_array = cell(N_currents_array,1); % define cell array of electric fields generated by each of the currents

parfor n = 1:N_currents_array % create array of E-field functions generated by base currents located on the side of the dipole

    if n <= N_currents_array/2

        aux1 = currents_limits_array(n);

        aux2 = currents_limits_array(n+1);

    else

        aux1 = currents_limits_array(n+1);

        aux2 = currents_limits_array(n+2);

    end

    f_string = sprintf('@(c1,c2,c3)(c3 >= %.15f)*(c3 < %.15f)', aux1, aux2);

    current_J = Vector_field(Function3(@(c1,c2,c3)0),...
                             Function3(@(c1,c2,c3)0),...
                             Function3(eval(f_string)),...
                             'cart'); % Define current in z direction

    Currents_array{n} = current_J;

    N_height_in_support = ceil((aux2-aux1) / (2*half_l/N_height));

    Current_A = Green_integral(Green, current_J, 'no', 0, 0, aux1, 0, 0, aux2, 1, 1, N_height_in_support, 'cart'); % Compute vector potential produced by z current

    Es_array{n} = Current_A*(-1i*w) + Grad(Div(Current_A, d_x, d_y, d_z),d_x, d_y, d_z)*(1/(1i*w*epsilon*mu)); % Compute E-field produced by z current

    fprintf('Current number = %d\n', n);

end



%% Define weighting functions

Weights = cell(N_weights,1);

parfor n = 1:N_weights
       
    aux1 = weights_limits(n);

    aux2 = weights_limits(n+1);
    
    f_string = sprintf('@(c1,c2,c3)(c3 >= %.15f)*(c3 < %.15f)', aux1, aux2);
    
    Weights{n} = Vector_field(Function3(@(c1,c2,c3)0),...
                              Function3(@(c1,c2,c3)0),...
                              Function3(eval(f_string)),...
                              'cart'); % Define weighting current in z direction
                          
    fprintf('Weight number = %d\n', n); 
    
end

if compute_array

    Weights_array = cell(N_weights_array,1);

    parfor n = 1:N_weights_array

        if n <= N_weights_array/2

            aux1 = weights_limits_array(n);

            aux2 = weights_limits_array(n+1);

        else

            aux1 = weights_limits_array(n+1);

            aux2 = weights_limits_array(n+2);

        end


        f_string = sprintf('@(c1,c2,c3)(c3 >= %.15f)*(c3 < %.15f)', aux1, aux2);

        Weights_array{n} = Vector_field(Function3(@(c1,c2,c3)0),...
                                        Function3(@(c1,c2,c3)0),...
                                        Function3(eval(f_string)),...
                                        'cart'); % Define weighting current in z direction

        fprintf('Weight number = %d\n', n); 

    end

end


%%  Create Z matrix and right-hand column vector

Z_Matrix = zeros(N_weights, N_currents); % initialize Z matrix

Result_col = zeros(N_weights,1); % initialize right hand column vector

waitbar_handle = waitbar(0,'Populating Z-matrix elements');

for m = 1:N_weights % calculate members of z matrx and results vector
       
    aux1 = weights_limits(m);

    aux2 = weights_limits(m+1);
   
    
    N_height_in_support = 2*floor(ceil((aux2-aux1) / (2*half_l/N_height))/2)+1;
    
    Result_col(m) = Integral(Einc * Weights{m}, R, 0, aux1, R, 2*pi*(N_phi-1)/N_phi, aux2, 1, N_phi, N_height_in_support, 'cyl');

    parfor n = 1:N_currents
        
        Z_Matrix(m,n) = Integral(Es{n} * Weights{m}, R, 0, aux1, R, 2*pi*(N_phi-1)/N_phi, aux2, 1, N_phi, N_height_in_support, 'cyl');
        
    end
    
    waitbar(m/N_weights, waitbar_handle);

end

close(waitbar_handle);

if compute_array

    Z_Matrix_array = zeros(N_weights_array, N_currents_array); % initialize Z matrix

    Result_col_array = zeros(N_weights_array,1); % initialize right hand column vector

    waitbar_handle = waitbar(0,'Populating array Z-matrix elements');

    for m = 1:N_weights_array % calculate members of z matrx and results vector

        if m <= N_weights_array/2

            aux1 = weights_limits_array(m);

            aux2 = weights_limits_array(m+1);

        else

            aux1 = weights_limits_array(m+1);

            aux2 = weights_limits_array(m+2);

        end

        N_height_in_support = 2*floor(ceil((aux2-aux1) / (2*half_l/N_height))/2)+1;

        Result_col_array(m) = Integral(Einc_array * Weights_array{m}, R, 0, aux1, R, 2*pi*(N_phi-1)/N_phi, aux2, 1, N_phi, N_height_in_support, 'cyl');

        parfor n = 1:N_currents_array

            Z_Matrix_array(m,n) = Integral(Es_array{n} * Weights_array{m}, R, 0, aux1, R, 2*pi*(N_phi-1)/N_phi, aux2, 1, N_phi, N_height_in_support, 'cyl');

        end

        waitbar(m/N_weights_array, waitbar_handle);

    end

    close(waitbar_handle);

end

%% Compute coefficients of the MOM

Field_coefficients = ((Z_Matrix') * Z_Matrix) \ (Z_Matrix') * Result_col; % solve for coefficients in LMSE sense

msgbox(sprintf('Residual is %0.3e', sum(abs(Z_Matrix*Field_coefficients - Result_col))));

if compute_array

    Field_coefficients_array = ((Z_Matrix_array') * Z_Matrix_array) \ (Z_Matrix_array') * Result_col_array; % solve for coefficients in LMSE sense

    msgbox(sprintf('Array residual is %0.3e', sum(abs(Z_Matrix_array*Field_coefficients_array - Result_col_array))));

end

%% Assemble scattered field

Es_ext_element = cell(N_currents,1);

parfor n = 1:N_currents % Compute E-fields of base currents multiplied by found coefficients. Utilizes simpler Green integral form than one used in matching points
    
    Es_ext_element{n} = Es{n}*Field_coefficients(n);
       
    fprintf('Current = %d\n', n);
    
end

waitbar_handle = waitbar(0,'Assembling scattered field of single element');

for n = 1:N_currents % Summarize fields of adjusted base currents to get total scattered field

    if n == 1

        Scattered_field_element = Es_ext_element{n};
 
    else

        Scattered_field_element = Scattered_field_element + (Es_ext_element{n});

    end

    waitbar(n/N_currents_array, waitbar_handle);

end

close(waitbar_handle);


Es_ext = cell(N_currents_array,1);   

parfor n = 1:N_currents_array % Compute E-fields of base currents multiplied by found coefficients. Utilizes simpler Green integral form than one used in matching points
    
    if n <= N_currents   
    
        Es_ext{n} = Es_array{n}*Field_coefficients(n);
    
    else
        
        Es_ext{n} = Es_array{n}*Field_coefficients(n - N_currents);
        
    end
       
    fprintf('Current = %d\n', n);
    
end

waitbar_handle = waitbar(0,'Assembling scattered field ');

for n = 1:N_currents_array % Summarize fields of adjusted base currents to get total scattered field

    if n == 1

        Scattered_field = Es_ext{n};
 
    else

        Scattered_field = Scattered_field + (Es_ext{n});

    end

    waitbar(n/N_currents_array, waitbar_handle);

end

close(waitbar_handle);

if compute_array

    Es_ext_array = cell(N_currents_array,1);   

    parfor n = 1:N_currents_array % Compute E-fields of base currents multiplied by found coefficients. Utilizes simpler Green integral form than one used in matching points

           Es_ext_array{n} = Es_array{n}*Field_coefficients_array(n);

           fprintf('Current = %d\n', n);

    end

    waitbar_handle = waitbar(0,'Assembling array scattered field ');

    for n = 1:N_currents_array % Summarize fields of adjusted base currents to get total scattered field

        if n == 1

            Scattered_field_array = Es_ext_array{n};

        else

            Scattered_field_array = Scattered_field_array + (Es_ext_array{n});

        end

        waitbar(n/N_currents_array, waitbar_handle);

    end

    close(waitbar_handle);

end


%% Visualize Far Field and array factor

if plot_FF % plot far-field radiation curves

    figure;

    Far_R = 10000; % choosing distance which is >> Lambda certainly >> than dipole size

    N_teta = 101;
    
    FF_E_sc_element = zeros(1, N_teta);

    FF_E_sc = zeros(1, N_teta);
    
    if compute_array
        
        FF_E_sc_array = zeros(1, N_teta);
        
    end
    
    FF_E_theoretical = zeros(1, N_teta);

    teta = linspace(0,2*pi,N_teta);

    for n = 1:N_teta
        
        FF_E_sc_element(n) = abs(Scattered_field_element(Coordinate(Far_R*sin(teta(n)), 0, Far_R*cos(teta(n)))));

        FF_E_sc(n) = abs(Scattered_field(Coordinate(Far_R*sin(teta(n)), 0, Far_R*cos(teta(n)))));
        
        if compute_array
            
            FF_E_sc_array(n) = abs(Scattered_field_array(Coordinate(Far_R*sin(teta(n)), 0, Far_R*cos(teta(n)))));
            
        end

        if sin(teta(n)) == 0
            
            FF_E_theoretical(n) = 0;
            
        else
        
            FF_E_theoretical(n) = (cos(w/c*half_l*cos(teta(n))) - cos(w/c*half_l))/sin(teta(n))*cos(w/c*D/2*cos(teta(n)));
            
        end
        
    end
    
    AF_computed = zeros(1, N_teta);
    
    AF_theoretical = zeros(1, N_teta);
    
    for n = 1:N_teta
        
        if FF_E_sc_element(n) ~= 0
        
            AF_computed(n) = FF_E_sc(n) / FF_E_sc_element(n);
            
        else
            
            AF_computed(n) = 0;
            
        end
        
        AF_theoretical(n) = cos(w/c*D/2*cos(teta(n)));
        
    end
    
    figure();    

    polar(teta, FF_E_sc / max(FF_E_sc), '-b');
    
    hold on;
    
    if compute_array
    
        polar(teta, FF_E_sc_array / max(FF_E_sc_array), '-g');
    
    end
    
    polar(teta, abs(FF_E_theoretical/max(FF_E_theoretical)), '-r');
    
    hold off;
    
    title('Normalized radiation pattern');
    
    if compute_array
        
        legend('Computed', 'Computed array', 'Theoretical');
        
    else
    
        legend('Computed', 'Theoretical');
    
    end
    
    view([90 -90]);
    
    figure()
    
    polar(teta, AF_computed / max(AF_computed), '-b');
    
    hold on;
    
    polar(teta, AF_theoretical / max(AF_theoretical), '-r');
    
    hold off;
    
    legend('Computed', 'Theoretical');
    
    title('Normalized array factor');

end

%% Visualize current_distribution (for array only)

if compute_array

    if plot_current

        for n = 1:N_currents_array


            if n == 1

                Cumulative_current_array = Currents_array{n} * Field_coefficients_array(n);

            else

                Cumulative_current_array = Cumulative_current_array + Currents_array{n} * Field_coefficients_array(n);

            end    



        end

        Current_to_plot = zeros(1, N_height);

        height = [linspace(-half_l - D/2, half_l - D/2, N_height) linspace(-half_l + D/2, half_l + D/2, N_height)];

        for n = 1:2*N_height

            Current_to_plot(n) = abs(Cumulative_current_array(Coordinate(0,0,height(n))));

        end

        figure();

        plot(height, Current_to_plot);

        title('Z directed currents map');

        xlabel('Z'); ylabel('Currents,[A]');

    end

end

